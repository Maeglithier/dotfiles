#!/usr/bin/env bash
# This script was generated by bashly 1.1.10 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
rpgmaker_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker - A program to make rpg maker mv/mz games playable in linux\n"
    echo

  else
    printf "rpgmaker - A program to make rpg maker mv/mz games playable in linux\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker [OPTIONS] COMMAND\n"
  printf "  rpgmaker [COMMAND] --help | -h\n"
  printf "  rpgmaker --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Configure and install the Game Engine. Only need to run once. Can be used to update the Engine.\n" "$(green "configure")"
  printf "  %s   Prepare the game for the Linux environment.\n" "$(green "setup")    "
  printf "  %s   Update the pixi.js and enhance performance, but might cause erros.\n" "$(green "update")   "
  printf "  %s   Decrypt game files.\n" "$(green "decrypt")  "
  printf "  %s   Optimize Image and Audio file and reduce overall file size. Require decrypted game files.\n" "$(green "optimize") "
  printf "  %s   Testar coisas\n" "$(green "test")     "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--debug, -d")"
    printf "    Enable debug mode\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
rpgmaker_configure_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker configure - Configure and install the Game Engine. Only need to run once. Can be used to update the Engine.\n"
    echo

  else
    printf "rpgmaker configure - Configure and install the Game Engine. Only need to run once. Can be used to update the Engine.\n"
    echo

  fi

  printf "Alias: c, config\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker configure\n"
  printf "  rpgmaker configure --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
rpgmaker_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker setup - Prepare the game for the Linux environment.\n"
    echo

  else
    printf "rpgmaker setup - Prepare the game for the Linux environment.\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker setup [GAME_PATH] [OPTIONS]\n"
  printf "  rpgmaker setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--update, -u")"
    printf "    Update the pixi.js and enhance performance, but might cause erros.\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--decrypt, -d")"
    printf "    Decrypt game files.\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--optimize, -o")"
    printf "    Optimize Image and Audio file and reduce overall file size. Require\n    decrypted game files.\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--video, -v")"
    printf "    Optimize video files. May take a while, maybe 1 hour or more. Require\n    --optimize flag.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "GAME_PATH")"
    printf "    Set the game path. If not specified, the current directory will be used.\n"
    echo

  fi
}

# :command.usage
rpgmaker_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker update - Update the pixi.js and enhance performance, but might cause erros.\n"
    echo

  else
    printf "rpgmaker update - Update the pixi.js and enhance performance, but might cause erros.\n"
    echo

  fi

  printf "Alias: u\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker update [GAME_PATH]\n"
  printf "  rpgmaker update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "GAME_PATH")"
    printf "    Set the game path. If not specified, the current directory will be used.\n"
    echo

  fi
}

# :command.usage
rpgmaker_decrypt_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker decrypt - Decrypt game files.\n"
    echo

  else
    printf "rpgmaker decrypt - Decrypt game files.\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker decrypt [GAME_PATH]\n"
  printf "  rpgmaker decrypt --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "GAME_PATH")"
    printf "    Set the game path. If not specified, the current directory will be used.\n"
    echo

  fi
}

# :command.usage
rpgmaker_optimize_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker optimize - Optimize Image and Audio file and reduce overall file size. Require decrypted game files.\n"
    echo

  else
    printf "rpgmaker optimize - Optimize Image and Audio file and reduce overall file size. Require decrypted game files.\n"
    echo

  fi

  printf "Alias: o\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker optimize [GAME_PATH] [OPTIONS]\n"
  printf "  rpgmaker optimize --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--video, -v")"
    printf "    Optimize video files. May take a while, maybe 1 hour or more. Require\n    --optimize flag.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "GAME_PATH")"
    printf "    Set the game path. If not specified, the current directory will be used.\n"
    echo

  fi
}

# :command.usage
rpgmaker_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "rpgmaker test - Testar coisas\n"
    echo

  else
    printf "rpgmaker test - Testar coisas\n"
    echo

  fi

  printf "Alias: t\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  rpgmaker test [GAME_PATH]\n"
  printf "  rpgmaker test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "GAME_PATH")"
    printf "    Set the game path. If not specified, the current directory will be used.\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# source/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# source/lib/configure_engine.sh
configure_engine() {
  _debug printf "configure_engine(): Entering...\\n"
  _debug printf "configure_engine(): \${@}:\\n%s\\n" "${@}"

  local _url="https://nwjs.io/versions"
  local _tmp_versions="/tmp/versions.json"
  local _current="${XDG_DATA_HOME:-${HOME}/.local/share}/nwjs/version.txt"
  local _source_path="${1}"

  # Function to download, extract NWJS. Copy "Game.sh" to "target_dir"
  download() {
    _debug printf "configure_engine(): download(): Entering...\\n"
    _debug printf "configure_engine(): download(): \${@}:\\n%s\\n" "${@}"

    local _version=${1}
    local _url="https://dl.nwjs.io/${_version}/nwjs-sdk-${_version}-linux-x64.tar.gz"
    local _tmp_file="/tmp/nwjs-sdk-${_version}-linux-x64.tar.gz"
    local _extract_dir="/tmp/nwjs-sdk-${_version}-linux-x64"
    local _target_dir="${XDG_DATA_HOME:-${HOME}/.local/share}/nwjs"

    _debug printf "configure_engine(): download(): \${_url}:\\n%s\\n" "${_url}"
    printf "Downloading nwjs %s...\\n" "${_version}"
    if ! curl -fSL -o "${_tmp_file}" "${_url}"; then
      _exit_1 printf "Error: Failed to download nwjs ${_version}\\n"
    fi

    printf "Extracting nwjs %s...\\n" "${_version}"
    if ! tar -xzf "${_tmp_file}" -C "/tmp"; then
      _exit_1 printf "Error: Failed to extract nwjs ${_version}\\n"
    fi

    printf "Installing nwjs %s...\\n" "${_version}"
    rm -rf "${_target_dir}"
    mkdir -p "${_target_dir}"

    _debug printf "configure_engine(): download(): Copy extacted to target dir...\\n"
    cp -R "${_extract_dir}"/* "${_target_dir}/"

    _debug printf "configure_engine(): download(): Copy Game.sh to target dir...\\n"
    cp "${_source_path}/storage/Game.sh" "${_target_dir}"
    mkdir -p "${_target_dir}/www"
    echo "${_version}" >"${_current}"

    _debug printf "configure_engine(): download(): Cleaning tmp files...\\n"
    rm -rf "${_tmp_file}"
    rm -rf "${_extract_dir}"

    printf "Installed nwjs %s\\n" "${_version}"
  }

  _debug printf "configure_engine(): Query \$_url for available versions\\n"
  printf "Querying available versions...\\n"
  if ! curl -fsSL -o "${_tmp_versions}" "${_url}"; then
    _exit_1 printf "Error: Failed to query available versions.\\n"
  fi

  local _latest
  _latest=$(jq -r '.latest' "${_tmp_versions}")
  local _versions
  _versions=$(jq -r '.versions[].version' "${_tmp_versions}" | head -20 | awk '{ORS = (NR%5 ? ", " : "\n")} {print}')

  printf "Listing 20 most recent versions:\\n%s\\n" "${_versions}"
  printf "Enter the version (including the v) you wish to download.\\nLeft blank and press Enter to download the latest version.\\n"

  read -r _input

  _debug printf "configure_engine(): Check if the user enter a valid version, if empty then download the latest version\\n"
  _debug printf "configure_engine(): cat \$_current:\\n%s\\n" "$(cat "${_current}")"
  _debug printf "configure_engine(): \$_latest:\\n%s\\n" "${_latest}"
  if [[ -n "${_input}" ]]; then
    _debug printf "configure_engine(): Check if \$_input is a valid \$_versions\\n"
    _debug printf "configure_engine(): \$_input:\\n%s\\n" "${_input}"
    _debug printf "configure_engine(): \$_versions:\\n%s\\n" "${_versions}"
    if [[ "${_versions}" == *"${_input}"* ]]; then
      download "${_input}"
    else
      _exit_1 printf "Error: \"%s\" is not a valid version.\\n" "${_input}"
    fi
  elif [[ ! -f "${_current}" ]] || [[ $(cat "${_current}") != "${_latest}" ]]; then
    _debug printf "configure_engine(): \$_current do not exist or is not equal \$_latest\\n"
    download "${_latest}"
  else
    printf "Already up to date.\\nCurrent version: %s\\n" "$(cat "${_current}")"
  fi
}

# source/lib/debug.sh
__DEBUG_COUNTER=0
_debug() {
  if ((${_USE_DEBUG:-0})); then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER + 1))
    {
      printf "🐛  %s " "${__DEBUG_COUNTER}"
      "${@}"
      printf "―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\\n"
    } 1>&2
  fi
}

# source/lib/decrypt_files.sh
decrypt_files() {
  _debug printf "decrypt_files(): Entering...\\n"
  _debug printf "decrypt_files(): \${@}:\\n%s\\n" "${@}"

  local _gamePath="${1}"
  local _source_path="${2}"

  _debug printf "decrypt_files(): Check if input path is a RPG Maker MV/MZ game\\n"
  if [[ ! -d "${_gamePath}/www" ]]; then
    _exit_1 printf "Error: Input path is not a RPG Maker MV/MZ game\\n"
  fi

  _debug printf "decrypt_files(): Searching for a custom encryption plugin\\n"
  local _plugins
  local _defaultEncryption=0
  _plugins=$(cat "${_gamePath}/www/js/plugins.js")

  if echo "${_plugins}" | grep -q -E "Art_Decrypterator3000"; then
    _defaultEncryption=1
    _exit_1 printf "Error: This game use Encrypterator 3000\\nUnless there is an available decryptor, this game cannot be decrypted with this scritp\\n"
  fi

  if echo "${_plugins}" | grep -q -E "POR_AssetDecoder"; then
    _defaultEncryption=1

    _deps "node" "install it by running: sudo apt install nodejs\\n"

    _debug printf "decrypt_files(): Using POE_decrypt tool to try decrypt files\\n"
    printf "Decrypting game files (POE Encryption)...\\n"

    _debug printf "decrypt_files(): Copy the plugin script and export the decodeFile function\\n"
    cp "${_gamePath}/www/js/plugins/POR_AssetDecoder.js" "${_source_path}/storage/POR_AssetDecoder.js"
    printf "\\nmodule.exports = decodeFile;\\n" >>"${_source_path}/storage/POR_AssetDecoder.js"

    _debug printf "decrypt_files(): Using node to decrypt the default .ext + \"o\" pattern\\n"
    node "${_source_path}/storage/POE_decrypt.js" "$_gamePath"

    printf "Disabling POR_AssetDecoder plugin...\\n"
    sed -i 's/\("name"\s*:\s*"POR_AssetDecoder"\s*,"status"\s*:\s*\)true/\1false/' "${_gamePath}/www/js/plugins.js"

    local _extensions=(".oggo" ".m4ao" ".pngo" ".webmo" ".mp4o")
  fi

  if [[ ${_defaultEncryption} -eq 0 ]]; then
    _debug printf "decrypt_files(): Using default decryption tool\\n"
    printf "Decrypting game files...\\n"
    if ! java -jar "${_source_path}/storage/RPG Maker MV Decrypter.jar" decrypt "${_gamePath}" "${_gamePath}"; then
      _exit_1 "Error: Failed to decrypt.\\n"
    fi

    _debug printf "decrypt_files(): Cleaning...\\n"
    rm -r "./output" "./updateCache.pref"

    local _extensions=(".rpgmvo" ".rpgmvm" ".rpgmvp" ".ogg_" ".m4a_" ".png_")
  fi

  _debug printf "decrypt_files(): \${_extensions}:\\n%s\\n" "$(echo "${_extensions[@]}")"

  _debug printf "decrypt_files(): Deleting encrypted files\\n"
  for ext in "${_extensions[@]}"; do
    _debug printf "decrypt_files(): Delete \${ext}:\\n%s\\n" "${ext}"
    find "${_gamePath}" -type f -name "*${ext}" -delete
  done

  _debug printf "decrypt_files(): Edit package.json to load decrypted files\\n"
  jq '.hasEncryptedAudio = false | .hasEncryptedImages = false' "${_gamePath}/www/data/System.json" >"${_gamePath}/www/data/System.json.tmp"
  mv "${_gamePath}/www/data/System.json.tmp" "${_gamePath}/www/data/System.json"
}

# source/lib/dependencie.sh
_deps() {
  if ! command -v "${1}" >/dev/null 2>&1; then
    {
      _warn printf "Error: Dependencie \"%s\" not found\\n" "${1}"
      _exit_1 printf "${2}\\n"
    } 1>&2
  fi
}

# source/lib/error.sh
_exit_1() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
  exit 1
}

_return_1() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
  return 1
}

_warn() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
}

# source/lib/game_setup.sh
game_setup() {
  _debug printf "game_setup(): Entering...\\n"
  _debug printf "game_setup(): \${@}:\\n%s\\n" "${@}"
  local _gamePath="${1}"

  # See: https://github.com/Revival8697/RPG-Maker-MV-MZ-Linux-Guide/blob/main/game-setup.sh

  _debug printf "game_setup(): Check if the directory is a RPG Maker MV/MZ game\\n"
  if [[ ! -f "${_gamePath}/package.json" ]]; then
    _exit_1 printf "Error: Input path is not a RPG Maker MV/MZ game.\\n"
  fi

  _debug printf "game_setup(): Check if the game is MV or MZ\\n"
  if [[ -d "${_gamePath}/www" ]]; then
    echo "Detected: RPG Maker MV game."

    _debug printf "game_setup(): Delete everything except \"www\" and \"package.json\"\\n"
    find "${_gamePath}" -mindepth 1 -maxdepth 1 ! -name "www" ! -name "package.json" -exec rm -rf {} \;
  else
    echo "Detected: RPG Maker MZ game."
    echo "Repackaging..."

    mkdir "${_gamePath}/www"

    _debug printf "game_setup(): Folders and files that will not be copied to the \"www\" folder\\n"
    local _excludedItems=("www" "captures" "locales" "swiftshader" "credits.html" "d3dcompiler_47.dll" "ffmpeg.dll" "Game.exe" "icudtl.dat" "libEGL.dll" "libGLESv2.dll" "node.dll" "notification_helper.exe" "nw_100_percent.pak" "nw_200_percent.pak" "nw_elf.dll" "nw.dll" "resources.pak" "v8_context_snapshot.bin")
    _debug printf "game_setup(): \${_excludedItems}:\\n%s\\n" "$(echo "${_excludedItems[@]}")"

    is_excluded() {
      local item="${1}"
      for excluded in "${_excludedItems[@]}"; do
        if [[ "${excluded}" == "${item}" ]]; then
          return 0
        fi
      done
      return 1
    }

    _debug printf "game_setup(): Copy folder and files not in _excludedItems\\n"
    for item in "${_gamePath}"/*; do
      local _baseItem
      _baseItem=$(basename "${item}")
      if ! is_excluded "${_baseItem}"; then
        _debug printf "game_setup(): cp -r \$item:\\n%s\\n" "$item"
        cp -r "${item}" "${_gamePath}/www"
      fi
    done

    _debug printf "game_setup(): Delete everything except \"www\"\\n"
    find "${_gamePath}" -mindepth 1 -maxdepth 1 ! -name "www" -exec rm -rf {} \;

    _debug printf "game_setup(): Copy and edit MZ \"package.json\"\\n"
    if [ -e "${_gamePath}/www/package.json" ]; then
      cp "${_gamePath}/www/package.json" "${_gamePath}/package.json"
      jq '.main = "www/index.html" | .window.icon = "www/icon/icon.png"' "${_gamePath}/package.json" >"${_gamePath}/package.json.temp"
      mv "${_gamePath}/package.json.temp" "${_gamePath}/package.json"
    else
      _exit_1 printf "Error: package.json does not exist in the 'www' directory.\\n"
    fi
  fi

  _debug printf "game_setup(): Fill the \"name\" parameter with the game folder name\\n"
  local _name
  _name=$(basename "${_gamePath}")
  _debug printf "game_setup(): \$_name:\\n%s\\n" "$_name"
  jq --arg name "${_name}" '.name = $name' "${_gamePath}/package.json" >"${_gamePath}/package.json.temp"
  mv "${_gamePath}/package.json.temp" "${_gamePath}/package.json"

  _debug printf "game_setup(): Create the game launcher\\n"
  ln -sf "${XDG_DATA_HOME:-${HOME}/.local/share}/nwjs/Game.sh" "${_gamePath}/Game.sh"
}

# source/lib/optimize_files.sh
optimize_files() {
  _debug printf "optimize_files(): Entering...\\n"
  _debug printf "optimize_files(): \${@}:\\n%s\\n" "${@}"

  local _gamePath="${1}"
  local _source_path="${2}"
  local _optimizeVideo="${3}"

  _debug printf "optimize_files(): Check if input path is a RPG Maker MV/MZ game\\n"
  if [[ ! -d "${_gamePath}/www" ]]; then
    _exit_1 printf "Error: Input path is not a RPG Maker MV/MZ game\\n"
  fi

  _debug printf "optimize_files(): Check if files are encrypted\\n"
  local _hasEncryptedImages
  local _hasEncryptedAudio
  _hasEncryptedImages=$(jq -r '.hasEncryptedImages' "${_gamePath}/www/data/System.json")
  _hasEncryptedAudio=$(jq -r '.hasEncryptedAudio' "${_gamePath}/www/data/System.json")
  if [[ "${_hasEncryptedImages}" == "true" ]] || [[ "${_hasEncryptedAudio}" == "true" ]]; then
    _warn printf "Warning: Files are encrypted. Running decrypt command now.\\n"
    decrypt "${_gamePath}" "${_source_path}"
    _debug printf "optimize_files(): Return to optimize\\n"
    printf "Files are decrypted. Resuming optimization...\\n"
  fi

  _debug printf "optimize_files(): Check if backup exist\\n"
  if [ ! -d "${_gamePath}/www_backup" ]; then
    _debug printf "optimize_files(): Creating a backup\\n"
    cp -R "${_gamePath}/www" "${_gamePath}/www_backup"
  else
    printf "Backup already exists. Skipping backup.\\n"
  fi

  _debug printf "optimize_files(): Check if icon exist\\n"
  if [ -f "${_gamePath}/www/icon/icon.png" ]; then
    _debug printf "optimize_files(): Optimize icon\\n"
    oxipng --opt max --strip all "${_gamePath}/www/icon/icon.png"
  else
    echo >&2 "Icon doesn't exist. Ignoring."
  fi

  optimize_image() {
    local file="$1"
    if pngcheck -v "$file" | grep -q -E "acTL"; then
      oxipng --opt max --strip safe "$file" || echo >&2 "oxipng failed on $file. Continuing"
    else
      cwebp -lossless "$file" -o "$file" || echo >&2 "cwebp failed on $file. Continuing."
    fi
  }

  optimize_audio() {
    local file="$1"
    local output="${file%.ogg}.opus"
    ffmpeg -i "$file" -c:a libopus "${output}"
    mv "${output}" "$file"
  }

  optimize_video() {
    local file="$1"
    local output="${file%.webm}.optimized.webm"
    ffmpeg -i "$file" -c:v libvpx-vp9 -c:a libopus -crf 40 -b:v 2000kB -deadline realtime "${output}"
    mv "${output}" "$file"
  }

  export -f optimize_image
  export -f optimize_audio
  export -f optimize_video

  _debug printf "optimize_files(): Finding .png files and optimizing...\\n"
  printf "Optmizing image files...\\n"
  find "${_gamePath}/www" -type f -name "*.png" ! -name "icon.png" | parallel optimize_image

  _debug printf "optimize_files(): Fiding .ogg files and optimizing...\\n"
  printf "Optmizing audio files...\\n"
  find "${_gamePath}/www" -type f -name "*.ogg" | parallel optimize_audio

  if [[ ${_optimizeVideo} -eq 1 ]]; then
    _debug printf "optimize_files(): Fiding .webm files and optimizing\\n"
    printf "Optmizing video files (May take a while)...\\n"
    mapfile -t _videoFiles < <(find "${_gamePath}/www" -type f -name "*.webm")
    for file in "${_videoFiles[@]}"; do
      optimize_video "${file}"
    done
  fi

  printf "Disabling AudioStreaming plugin...\\n"
  sed -i 's/\("name"\s*:\s*"AudioStreaming"\s*,"status"\s*:\s*\)true/\1false/' "${_gamePath}/www/js/plugins.js"
}

# source/lib/update_js.sh
update_js() {
  _debug printf "update_js(): Entering...\\n"
  _debug printf "update_js(): \${@}:\\n%s\\n" "${@}"

  local _gamePath="${1}"
  local _source_path="${2}"

  _debug printf "update_js(): Check if input path is a RPG Maker MV/MZ game\\n"
  if [[ ! -f "${_gamePath}/www/js/libs/pixi.js" ]]; then
    _exit_1 printf "Error: Input path is not a RPG Maker MV/MZ game\\n"
  else
    local _pixi="${_gamePath}/www/js/libs/pixi.js"
  fi

  copy_files() {
    _debug printf "update_js(): copy_files(): Entering...\\n"
    _debug printf "update_js(): copy_files(): \${@}:\\n%s\\n" "${@}"

    local _variant=${1}

    printf "Updating the RPG Maker %s pixi.js\\n" "${_variant}"
    if [[ ! -d "${_gamePath}/www/js/libs_backup" ]]; then
      _debug printf "update_js(): copy_files(): Backup original files\\n"
      cp -r "${_gamePath}/www/js" "${_gamePath}/www/js_backup"
    fi
    cp -r "${_source_path}/storage/${_variant}"/* "${_gamePath}/www/js"
  }

  _debug printf "update_js(): Check if the game is MV or MZ\\n"
  if grep -q "pixi.js - v4." "${_pixi}"; then
    copy_files "MV"
  elif grep -q "pixi.js - v5." "${_pixi}"; then
    copy_files "MZ"
  else
    _exit_1 printf "Error: Can't detect pixi.js version."
  fi
}

# :command.command_functions
# :command.function
rpgmaker_configure_command() {
  # source/commands/configure.sh
  _USE_DEBUG=${args[--debug]:-0}
  _debug printf "configure(): Entering...\\n"
  _debug printf "configure(): \$(inspect_args):\\n%s\\n" "$(inspect_args)"

  _debug printf "configure(): Verifying depencendies...\\n"
  _deps "jq" "install it by running: sudo apt install jq\\n"
  _deps "curl" "install it by running: sudo apt install curl\\n"

  local _source_path="${RPGMAKER_SOURCE_PATH}"

  configure_engine "${_source_path}"

  printf "Finished!\\n"

}

# :command.function
rpgmaker_setup_command() {
  # source/commands/setup.sh
  _USE_DEBUG=${args[--debug]:-0}
  _debug printf "setup(): Entering...\\n"
  _debug printf "setup(): \$(inspect_args):\\n%s\\n" "$(inspect_args)"

  _debug printf "setup(): Verifying depencendies...\\n"
  local _update=${args[--update]:-0}
  local _decrypt=${args[--decrypt]:-0}
  local _optimize=${args[--optimize]:-0}
  local _optimizeVideo=${args[--video]:-0}
  _deps "jq" "install it by running: sudo apt install jq\\n"
  if [[ ${_decrypt} -eq 1 ]]; then
    _deps "java" "install it by running: sudo apt install default-jre\\n"
  fi
  if [[ ${_optimize} -eq 1 ]]; then
    _deps "pngcheck" "install it by running: sudo apt install pngcheck\\n"
    _deps "oxipng" "install from https://github.com/shssoichiro/oxipng/releases/latest\\n"
    _deps "cwebp" "install it by running: sudo apt install webp\\n"
    _deps "ffmpeg" "install it by running: sudo apt install ffmpeg\\n"
    _deps "parallel" "install it by running: sudo apt install parallel\\n"
  fi
  if [[ ${_optimizeVideo} -eq 1 ]]; then
    if [[ ! ${_optimize} -eq 1 ]]; then
      _exit_1 printf "The --video flag need to be used with the --optimize flag.\\n"
    fi
  fi

  local _source_path="${RPGMAKER_SOURCE_PATH}"
  local _gamePath="${args[game_path]:-$PWD}"
  _gamePath=$(realpath "${_gamePath}")
  _debug printf "setup(): \${_gamePath}:\\n%s\\n" "${_gamePath}"

  game_setup "${_gamePath}"

  if [[ ${_update} -eq 1 ]]; then
    update_js "${_gamePath}" "${_source_path}"
  fi

  if [[ ${_decrypt} -eq 1 ]]; then
    decrypt_files "${_gamePath}" "${_source_path}"
  fi

  if [[ ${_optimize} -eq 1 ]]; then
    optimize_files "${_gamePath}" "${_source_path}" "${_optimizeVideo}"
  fi

  _debug printf "setup(): Check if user has set up the Game Engine\\n"
  if [ ! -f "${XDG_DATA_HOME:-${HOME}/.local/share}/nwjs/Game.sh" ]; then
    _warn printf "Warning: Game Engine not found. Running configure command now.\\n"
    configure_engine "${_source_path}"
  fi

  printf "Finished!\\n"

}

# :command.function
rpgmaker_update_command() {
  # source/commands/update.sh
  _USE_DEBUG=${args[--debug]:-0}
  _debug printf "update(): Entering...\\n"
  _debug printf "update(): \$(inspect_args):\\n%s\\n" "$(inspect_args)"

  _debug printf "update(): Verifying depencendies...\\n"
  _deps "jq" "install it by running: sudo apt install jq\\n"

  local _source_path="${RPGMAKER_SOURCE_PATH}"
  local _gamePath="${args[game_path]:-$PWD}"
  _gamePath=$(realpath "${_gamePath}")
  _debug printf "update(): \${_gamePath}:\\n%s\\n" "${_gamePath}"

  update_js "${_gamePath}" "${_source_path}"

  printf "Finished!\\n"

}

# :command.function
rpgmaker_decrypt_command() {
  # source/commands/decrypt.sh
  _USE_DEBUG=${args[--debug]:-0}
  _debug printf "setup(): Entering...\\n"
  _debug printf "setup(): \$(inspect_args):\\n%s\\n" "$(inspect_args)"

  _debug printf "setup(): Verifying depencendies...\\n"
  _deps "jq" "install it by running: sudo apt install jq\\n"
  _deps "java" "install it by running: sudo apt install default-jre\\n"

  local _source_path="${RPGMAKER_SOURCE_PATH}"
  local _gamePath="${args[game_path]:-$PWD}"
  _gamePath=$(realpath "${_gamePath}")
  _debug printf "setup(): \${_gamePath}:\\n%s\\n" "${_gamePath}"

  decrypt_files "${_gamePath}" "${_source_path}"

  printf "Finished!\\n"

}

# :command.function
rpgmaker_optimize_command() {
  # source/commands/optimize.sh
  _USE_DEBUG=${args[--debug]:-0}
  _debug printf "setup(): Entering...\\n"
  _debug printf "setup(): \$(inspect_args):\\n%s\\n" "$(inspect_args)"

  _debug printf "setup(): Verifying depencendies...\\n"
  local _optimizeVideo=${args[--video]:-0}
  _deps "jq" "install it by running: sudo apt install jq\\n"
  _deps "pngcheck" "install it by running: sudo apt install pngcheck\\n"
  _deps "oxipng" "install from https://github.com/shssoichiro/oxipng/releases/latest\\n"
  _deps "cwebp" "install it by running: sudo apt install webp\\n"
  _deps "ffmpeg" "install it by running: sudo apt install ffmpeg\\n"
  _deps "parallel" "install it by running: sudo apt install parallel\\n"

  local _source_path="${RPGMAKER_SOURCE_PATH}"
  local _gamePath="${args[game_path]:-$PWD}"
  _gamePath=$(realpath "${_gamePath}")
  _debug printf "setup(): \${_gamePath}:\\n%s\\n" "${_gamePath}"

  optimize_files "${_gamePath}" "${_source_path}" "${_optimizeVideo}"

  printf "Finished!\\n"

}

# :command.function
rpgmaker_test_command() {
  # source/commands/test.sh
  local _source_path="${RPGMAKER_SOURCE_PATH}"
  local _gamePath="${args[game_path]:-$PWD}"
  _gamePath=$(realpath "${_gamePath}")


  _warn printf "We don't have any test!\\n"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        rpgmaker_usage
        exit
        ;;

      # :flag.case
      --debug | -d)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export RPGMAKER_SOURCE_PATH="${RPGMAKER_SOURCE_PATH:-${HOME}/.local/src/Rpg Maker Linux}"

  env_var_names+=("RPGMAKER_SOURCE_PATH")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    configure | c | config)
      action="configure"
      shift
      rpgmaker_configure_parse_requirements "$@"
      shift $#
      ;;

    setup | s)
      action="setup"
      shift
      rpgmaker_setup_parse_requirements "$@"
      shift $#
      ;;

    update | u)
      action="update"
      shift
      rpgmaker_update_parse_requirements "$@"
      shift $#
      ;;

    decrypt | d)
      action="decrypt"
      shift
      rpgmaker_decrypt_parse_requirements "$@"
      shift $#
      ;;

    optimize | o)
      action="optimize"
      shift
      rpgmaker_optimize_parse_requirements "$@"
      shift $#
      ;;

    test | t)
      action="test"
      shift
      rpgmaker_test_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      rpgmaker_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
rpgmaker_configure_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        rpgmaker_configure_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="configure"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
rpgmaker_setup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        rpgmaker_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --update | -u)

        # :flag.case_no_arg
        args['--update']=1
        shift
        ;;

      # :flag.case
      --decrypt | -d)

        # :flag.case_no_arg
        args['--decrypt']=1
        shift
        ;;

      # :flag.case
      --optimize | -o)

        # :flag.case_no_arg
        args['--optimize']=1
        shift
        ;;

      # :flag.case
      --video | -v)

        # :flag.case_no_arg
        args['--video']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['game_path']+x} ]]; then
          args['game_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
rpgmaker_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        rpgmaker_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['game_path']+x} ]]; then
          args['game_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
rpgmaker_decrypt_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        rpgmaker_decrypt_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="decrypt"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['game_path']+x} ]]; then
          args['game_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
rpgmaker_optimize_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        rpgmaker_optimize_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="optimize"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --video | -v)

        # :flag.case_no_arg
        args['--video']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['game_path']+x} ]]; then
          args['game_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
rpgmaker_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        rpgmaker_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['game_path']+x} ]]; then
          args['game_path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -euo pipefail

  # :command.environment_variables_default
  export RPGMAKER_SOURCE_PATH="${RPGMAKER_SOURCE_PATH:-${HOME}/.local/src/Rpg Maker Linux}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "configure") rpgmaker_configure_command ;;
    "setup") rpgmaker_setup_command ;;
    "update") rpgmaker_update_command ;;
    "decrypt") rpgmaker_decrypt_command ;;
    "optimize") rpgmaker_optimize_command ;;
    "test") rpgmaker_test_command ;;
  esac
}

initialize
run "$@"
